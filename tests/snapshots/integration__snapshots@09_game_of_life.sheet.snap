---
source: tests/integration.rs
expression: output
input_file: tests/scripts/09_game_of_life.sheet
---
--- CODE ---
// Conway's Game of Life
// Rules:
// - Any live cell (1) with 2-3 neighbors survives
// - Any dead cell (0) with exactly 3 neighbors becomes alive
// - All other cells die/stay dead

// Cell Z1 stores the Game of Life logic as a lambda function
// Takes: neighbor_count (n) and current_state (c)
// Returns: 1 (alive) or 0 (dead) as integer
// Uses || operator to return 1 if alive condition is true, otherwise 0
Z1 = (n, c) => (((c == 1) && (n == 2 || n == 3)) && 1) || ((n == 3) && 1) || 0

// initialize a 3x3 grid with dead cells
A1:C3 = 0

// create blinker
B1:B3 = 1

// apply
tick

// Slice assign the game of life rules
A1:C3 = Z1((@[-1,-1]||0) + (@[0,-1]||0) + (@[1,-1]||0) + (@[-1,0]||0) + (@[1,0]||0) + (@[-1,1]||0) + (@[0,1]||0) + (@[1,1]||0), @[0,0]||0)

// Run a few ticks to see the blinker pattern evolve
tick
tick
tick


--- PARSE & EXECUTION ---

[Tick 1]
A1: 0
B1: 1
C1: 0
Z1: <fn>
A2: 0
B2: 1
C2: 0
A3: 0
B3: 1
C3: 0

[Tick 2]
A1: 0
B1: 0
C1: 0
Z1: <fn>
A2: 1
B2: 1
C2: 1
A3: 0
B3: 0
C3: 0

[Tick 3]
A1: 0
B1: 1
C1: 0
Z1: <fn>
A2: 0
B2: 1
C2: 0
A3: 0
B3: 1
C3: 0

[Tick 4]
A1: 0
B1: 0
C1: 0
Z1: <fn>
A2: 1
B2: 1
C2: 1
A3: 0
B3: 0
C3: 0
