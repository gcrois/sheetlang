// Conway's Game of Life
// Rules:
// - Any live cell (1) with 2-3 neighbors survives
// - Any dead cell (0) with exactly 3 neighbors becomes alive
// - All other cells die/stay dead

// Cell Z1 stores the Game of Life logic as a lambda function
// Takes: neighbor_count (n) and current_state (c)
// Returns: 1 (alive) or 0 (dead) as integer
// Uses || operator to return 1 if alive condition is true, otherwise 0
Z1 = (n, c) => (((c == 1) && (n == 2 || n == 3)) && 1) || ((n == 3) && 1) || 0

// Use slice assignment to assign Game of Life formula to entire 10x10 grid
// Each cell counts its 8 neighbors using relative references, then calls Z1 lambda
A1:J10 = Z1((@[-1,-1]||0) + (@[0,-1]||0) + (@[1,-1]||0) + (@[-1,0]||0) + (@[1,0]||0) + (@[-1,1]||0) + (@[0,1]||0) + (@[1,1]||0), @[0,0]||0)

// NOW initialize the grid with a glider pattern (AFTER slice assignment)
// Glider is a simple pattern that moves diagonally
B2 = 1
C3 = 1
A4 = 1
B4 = 1
C4 = 1

// Glider Pattern Evolution:
// Tick 1: B2=1, C3=1, A4=1, B4=1, C4=1 (initial glider)
// Tick 2: A3=1, B2=1, C3=1, A4=1, B4=1, C4=1, B5=1 (glider evolves)
// The pattern continues to evolve and move diagonally across the grid!
//
// This demonstrates:
// 1. Slice assignments (A1:J10 = formula) working with complex formulas
// 2. Lambda functions storing reusable logic
// 3. Relative references (@[dx,dy]) for neighbor counting
// 4. Reactive evaluation - each tick computes based on previous state
